<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>deepfns.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Deepfns</span> <span class="project-version">0.1.1</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>deepfns</span></div></div></li><li class="depth-2 branch current"><a href="deepfns.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="deepfns.transitive.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>transitive</span></div></a></li><li class="depth-2"><a href="deepfns.utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="deepfns.core.html#var-.3C-.24.3E"><div class="inner"><span>&lt;-$&gt;</span></div></a></li><li class="depth-1"><a href="deepfns.core.html#var-.3C-*.3E"><div class="inner"><span>&lt;-*&gt;</span></div></a></li><li class="depth-1"><a href="deepfns.core.html#var-.3C.3D.3E"><div class="inner"><span>&lt;=&gt;</span></div></a></li><li class="depth-1"><a href="deepfns.core.html#var-deepfapply"><div class="inner"><span>deepfapply</span></div></a></li><li class="depth-1"><a href="deepfns.core.html#var-deepfmap"><div class="inner"><span>deepfmap</span></div></a></li><li class="depth-1"><a href="deepfns.core.html#var-deeppure"><div class="inner"><span>deeppure</span></div></a></li><li class="depth-1"><a href="deepfns.core.html#var-filterapply"><div class="inner"><span>filterapply</span></div></a></li><li class="depth-1"><a href="deepfns.core.html#var-pure"><div class="inner"><span>pure</span></div></a></li><li class="depth-1"><a href="deepfns.core.html#var-transitive"><div class="inner"><span>transitive</span></div></a></li><li class="depth-1"><a href="deepfns.core.html#var-zip"><div class="inner"><span>zip</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">deepfns.core</h1><div class="doc"><pre class="plaintext">General, category theory functions plus a few new ones.
</pre></div><div class="public anchor" id="var-.3C-.24.3E"><h3>&lt;-$&gt;</h3><div class="usage"></div><div class="doc"><pre class="plaintext">An alias for deepfmap
</pre></div><div class="src-link"><a href="https://github.com/greenyouse/deepfns/blob/master/src/deepfns/core.cljc#L94">view source</a></div></div><div class="public anchor" id="var-.3C-*.3E"><h3>&lt;-*&gt;</h3><div class="usage"></div><div class="doc"><pre class="plaintext">An alias for deepfapply
</pre></div><div class="src-link"><a href="https://github.com/greenyouse/deepfns/blob/master/src/deepfns/core.cljc#L205">view source</a></div></div><div class="public anchor" id="var-.3C.3D.3E"><h3>&lt;=&gt;</h3><div class="usage"></div><div class="doc"><pre class="plaintext">An alias for transitive
</pre></div><div class="src-link"><a href="https://github.com/greenyouse/deepfns/blob/master/src/deepfns/core.cljc#L455">view source</a></div></div><div class="public anchor" id="var-deepfapply"><h3>deepfapply</h3><div class="usage"><code>(deepfapply fs)</code><code>(deepfapply fs m)</code><code>(deepfapply fs m &amp; ms)</code></div><div class="doc"><pre class="plaintext">Similar to fapply but recursively evaluates all the arguments.

This basically applies a function that&apos;s wrapped in the same type
as the arguments and returns a collection of the same type.

See this Haskell page for more info:
<a href="https://en.wikibooks.org/wiki/Haskell/Applicative_Functors#Application_in_functors">https://en.wikibooks.org/wiki/Haskell/Applicative_Functors#Application_in_functors</a>

ex:
(deepfapply {:a +}
  {:a 1} {:a 1 :b 2})

=&gt; {:a 2 :b 2}</pre></div><div class="src-link"><a href="https://github.com/greenyouse/deepfns/blob/master/src/deepfns/core.cljc#L154">view source</a></div></div><div class="public anchor" id="var-deepfmap"><h3>deepfmap</h3><div class="usage"><code>(deepfmap f)</code><code>(deepfmap f m)</code><code>(deepfmap f m &amp; ms)</code></div><div class="doc"><pre class="plaintext">Like fmap but it will recursively evalute all nested collections.

If you&apos;re not already familiar, fmap is basically like map but it
guarantees that the type of the collection that&apos;s passed in as an
argument will remain unchanged when it comes out as a result.

See this Haskell page for more info:
<a href="https://en.wikibooks.org/wiki/Haskell/The_Functor_class">https://en.wikibooks.org/wiki/Haskell/The_Functor_class</a>

(deepfmap inc {:a 1 :b {:c 2}})

=&gt; {:a 2 :b {:c 3}}</pre></div><div class="src-link"><a href="https://github.com/greenyouse/deepfns/blob/master/src/deepfns/core.cljc#L48">view source</a></div></div><div class="public anchor" id="var-deeppure"><h3>deeppure</h3><div class="usage"><code>(deeppure m)</code><code>(deeppure m value)</code></div><div class="doc"><pre class="plaintext">This is a recursive version of pure. It will replace all values in
 the given type with value. All keys on maps will also be preserved.

(deeppure [1 []] 10)

=&gt; [10 [10]]</pre></div><div class="src-link"><a href="https://github.com/greenyouse/deepfns/blob/master/src/deepfns/core.cljc#L231">view source</a></div></div><div class="public anchor" id="var-filterapply"><h3>filterapply</h3><div class="usage"><code>(filterapply f)</code><code>(filterapply fs m)</code><code>(filterapply fs m &amp; ms)</code></div><div class="doc"><pre class="plaintext">The same as deepfapply but keys not in the applicative will not be
propagated.

(filterapply {:a +}
  {:a 1} {:a 1 :b 2})

=&gt; {:a 2}

NOTE: saves all metadata even if a collection gets filtered</pre></div><div class="src-link"><a href="https://github.com/greenyouse/deepfns/blob/master/src/deepfns/core.cljc#L289">view source</a></div></div><div class="public anchor" id="var-pure"><h3>pure</h3><div class="usage"><code>(pure m)</code><code>(pure m value)</code></div><div class="doc"><pre class="plaintext">Basically pure will take any collection and insert some value into it.

See this for more info:
<a href="https://en.wikibooks.org/wiki/Haskell/Applicative_Functors#The_Applicative_class">https://en.wikibooks.org/wiki/Haskell/Applicative_Functors#The_Applicative_class</a>

ex:
(pure [1] 10)

=&gt; [10]</pre></div><div class="src-link"><a href="https://github.com/greenyouse/deepfns/blob/master/src/deepfns/core.cljc#L248">view source</a></div></div><div class="public anchor" id="var-transitive"><h3>transitive</h3><div class="usage"><code>(transitive f)</code><code>(transitive f m)</code><code>(transitive f m &amp; ms)</code></div><div class="doc"><pre class="plaintext">Takes a transitive and uses that to walk a datastructure, accumulating
the results into the applicative as it goes.

ex:
((transitive {:a :foo :b {:c :bar}})
  {:foo 1 :bar 2 :fizz 3})

=&gt; {:a 1 :b {:c 2}}</pre></div><div class="src-link"><a href="https://github.com/greenyouse/deepfns/blob/master/src/deepfns/core.cljc#L425">view source</a></div></div><div class="public anchor" id="var-zip"><h3>zip</h3><div class="usage"><code>(zip x)</code><code>(zip fs x)</code><code>(zip fs x y)</code><code>(zip fs x y &amp; args)</code></div><div class="doc"><pre class="plaintext">Similar to zip-list but it handles nested data and maps too. Each
function in the fs collection will be applied to the argument at
that position (vectors + seqs) or the matching key (maps). The
1-arity version will return an infinite seq of the item.

Here is more info on zip-list:
<a href="https://en.wikibooks.org/wiki/Haskell/Applicative_Functors#ZipList">https://en.wikibooks.org/wiki/Haskell/Applicative_Functors#ZipList</a>

ex:
(zip [+ -] [1 2 3] [4 5] [6 1])

=&gt; [11 -4]

 (zip {:a inc :b dec}
   {:a 1 :b {:c 2 :d 3}})

=&gt; {:a 2 :b {:c 1 :d 2}}

NOTE: This is not compatible with sets, only lists, seqs, and maps.</pre></div><div class="src-link"><a href="https://github.com/greenyouse/deepfns/blob/master/src/deepfns/core.cljc#L348">view source</a></div></div></div></body></html>